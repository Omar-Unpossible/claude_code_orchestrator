"""AST-based code validators for prompt rule enforcement.

This module provides code quality validators that use Python's Abstract Syntax Tree (AST)
to detect:
- Stub functions (pass, TODO, NotImplemented)
- Hardcoded values (magic numbers, hardcoded strings)
- Missing docstrings
- Missing test coverage

Used by PromptRuleEngine to validate code generated by LLMs.

Part of the LLM-first prompt engineering framework (PHASE_2, TASK_2.4).
"""

import ast
import re
from pathlib import Path
from typing import List, Dict, Any, Optional, Set
import logging

logger = logging.getLogger(__name__)


class CodeViolation:
    """Represents a single code quality violation."""

    def __init__(
        self,
        file_path: str,
        line: int,
        column: int,
        violation_type: str,
        message: str,
        severity: str = 'medium',
        suggestion: Optional[str] = None
    ):
        """Initialize code violation.

        Args:
            file_path: Path to file with violation
            line: Line number (1-indexed)
            column: Column number (0-indexed)
            violation_type: Type of violation (e.g., 'stub_function', 'hardcoded_value')
            message: Description of violation
            severity: Violation severity
            suggestion: Optional fix suggestion
        """
        self.file_path = file_path
        self.line = line
        self.column = column
        self.violation_type = violation_type
        self.message = message
        self.severity = severity
        self.suggestion = suggestion

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for logging/reporting."""
        return {
            'file': self.file_path,
            'line': self.line,
            'column': self.column,
            'type': self.violation_type,
            'message': self.message,
            'severity': self.severity,
            'suggestion': self.suggestion
        }

    def __repr__(self) -> str:
        return f"<CodeViolation({self.file_path}:{self.line} - {self.violation_type})>"


def detect_stubs(code: str, file_path: str = '<string>') -> List[CodeViolation]:
    """Detect stub functions containing pass, TODO, or NotImplemented.

    Identifies functions/methods that are not fully implemented:
    - Functions with only 'pass' statement
    - Functions with 'raise NotImplementedError'
    - Functions with TODO/FIXME comments
    - Empty function bodies

    Args:
        code: Python source code to analyze
        file_path: Path to file (for reporting)

    Returns:
        List of CodeViolation objects for detected stubs

    Example:
        >>> code = '''
        ... def incomplete_func():
        ...     pass
        ...
        ... def another_func():
        ...     # TODO: implement this
        ...     pass
        ... '''
        >>> violations = detect_stubs(code)
        >>> assert len(violations) == 2
    """
    violations = []

    try:
        tree = ast.parse(code)
    except SyntaxError as e:
        logger.error(f"Syntax error in {file_path}: {e}")
        return violations

    for node in ast.walk(tree):
        if not isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            continue

        func_name = node.name
        func_line = node.lineno

        # Skip private/dunder methods (they can be stubs)
        if func_name.startswith('_') and not func_name.startswith('__test'):
            continue

        # Check function body
        if not node.body:
            violations.append(CodeViolation(
                file_path=file_path,
                line=func_line,
                column=node.col_offset,
                violation_type='empty_function',
                message=f"Function '{func_name}' has empty body",
                severity='critical',
                suggestion="Implement the function logic or remove if not needed"
            ))
            continue

        # Check for single 'pass' statement
        if len(node.body) == 1 and isinstance(node.body[0], ast.Pass):
            violations.append(CodeViolation(
                file_path=file_path,
                line=func_line,
                column=node.col_offset,
                violation_type='stub_function',
                message=f"Function '{func_name}' contains only 'pass' statement",
                severity='critical',
                suggestion="Implement the function logic"
            ))

        # Check for NotImplementedError
        for stmt in node.body:
            if isinstance(stmt, ast.Raise):
                if isinstance(stmt.exc, ast.Call):
                    if hasattr(stmt.exc.func, 'id') and stmt.exc.func.id == 'NotImplementedError':
                        violations.append(CodeViolation(
                            file_path=file_path,
                            line=stmt.lineno,
                            column=stmt.col_offset,
                            violation_type='not_implemented',
                            message=f"Function '{func_name}' raises NotImplementedError",
                            severity='high',
                            suggestion="Implement the function logic or remove the placeholder"
                        ))

        # Check for TODO/FIXME comments in docstring or body
        if node.body and isinstance(node.body[0], ast.Expr) and isinstance(node.body[0].value, ast.Constant):
            docstring = node.body[0].value.value
            if isinstance(docstring, str):
                if re.search(r'\b(TODO|FIXME|XXX|HACK)\b', docstring, re.IGNORECASE):
                    violations.append(CodeViolation(
                        file_path=file_path,
                        line=func_line,
                        column=node.col_offset,
                        violation_type='todo_marker',
                        message=f"Function '{func_name}' contains TODO/FIXME marker",
                        severity='medium',
                        suggestion="Complete the implementation and remove TODO marker"
                    ))

    return violations


def detect_hardcoded_values(
    code: str,
    file_path: str = '<string>',
    ignore_numbers: Optional[Set[int]] = None
) -> List[CodeViolation]:
    """Detect hardcoded magic numbers and strings in code.

    Identifies hardcoded values that should be constants or configuration:
    - Magic numbers (excluding common values like 0, 1, 2, -1)
    - Hardcoded strings (excluding docstrings and type hints)
    - Hardcoded file paths
    - Hardcoded URLs

    Args:
        code: Python source code to analyze
        file_path: Path to file (for reporting)
        ignore_numbers: Set of numbers to ignore (e.g., {0, 1, -1})

    Returns:
        List of CodeViolation objects for detected hardcoded values

    Example:
        >>> code = '''
        ... def calculate(x):
        ...     return x * 3.14159  # Magic number
        ...
        ... API_URL = "http://localhost:8080"  # Hardcoded URL
        ... '''
        >>> violations = detect_hardcoded_values(code)
        >>> assert any(v.violation_type == 'magic_number' for v in violations)
    """
    if ignore_numbers is None:
        ignore_numbers = {0, 1, 2, -1, 100, 1000}  # Common safe numbers

    violations = []

    try:
        tree = ast.parse(code)
    except SyntaxError:
        return violations

    for node in ast.walk(tree):
        # Check for magic numbers
        if isinstance(node, ast.Constant):
            if isinstance(node.value, (int, float)):
                # Skip if in ignore list
                if node.value in ignore_numbers:
                    continue

                # Skip if it's a default argument value or return value
                parent = getattr(node, 'parent', None)
                if isinstance(parent, (ast.Return, ast.Assign)):
                    continue

                violations.append(CodeViolation(
                    file_path=file_path,
                    line=node.lineno,
                    column=node.col_offset,
                    violation_type='magic_number',
                    message=f"Magic number detected: {node.value}",
                    severity='medium',
                    suggestion="Extract to a named constant or configuration"
                ))

            # Check for hardcoded URLs/paths in strings
            elif isinstance(node.value, str):
                # Skip docstrings and type annotations
                if len(node.value) > 50 or '\n' in node.value:
                    continue

                # Check for URLs
                if re.match(r'https?://', node.value):
                    violations.append(CodeViolation(
                        file_path=file_path,
                        line=node.lineno,
                        column=node.col_offset,
                        violation_type='hardcoded_url',
                        message=f"Hardcoded URL detected: {node.value[:50]}",
                        severity='high',
                        suggestion="Move URL to configuration file or environment variable"
                    ))

                # Check for file paths
                elif '/' in node.value and len(node.value) > 5:
                    # Skip if it looks like a URL path (starts with /)
                    if not node.value.startswith('/api') and not node.value.startswith('/v'):
                        violations.append(CodeViolation(
                            file_path=file_path,
                            line=node.lineno,
                            column=node.col_offset,
                            violation_type='hardcoded_path',
                            message=f"Hardcoded path detected: {node.value[:50]}",
                            severity='medium',
                            suggestion="Use pathlib or configuration for file paths"
                        ))

    return violations


def check_docstring_coverage(code: str, file_path: str = '<string>') -> List[CodeViolation]:
    """Check for missing docstrings in public functions and classes.

    Verifies that all public (non-private) functions, methods, and classes
    have docstrings documenting their purpose and usage.

    Args:
        code: Python source code to analyze
        file_path: Path to file (for reporting)

    Returns:
        List of CodeViolation objects for missing docstrings

    Example:
        >>> code = '''
        ... def public_function(x, y):
        ...     return x + y  # Missing docstring
        ...
        ... def _private_function():
        ...     pass  # OK to skip docstring
        ... '''
        >>> violations = check_docstring_coverage(code)
        >>> assert len(violations) == 1
    """
    violations = []

    try:
        tree = ast.parse(code)
    except SyntaxError:
        return violations

    for node in ast.walk(tree):
        # Check functions and methods
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            func_name = node.name

            # Skip private functions/methods
            if func_name.startswith('_') and not func_name.startswith('__'):
                continue

            # Check for docstring
            has_docstring = (
                node.body and
                isinstance(node.body[0], ast.Expr) and
                isinstance(node.body[0].value, ast.Constant) and
                isinstance(node.body[0].value.value, str)
            )

            if not has_docstring:
                violations.append(CodeViolation(
                    file_path=file_path,
                    line=node.lineno,
                    column=node.col_offset,
                    violation_type='missing_docstring',
                    message=f"Function '{func_name}' missing docstring",
                    severity='medium',
                    suggestion="Add Google-style docstring with Args, Returns, and description"
                ))

        # Check classes
        elif isinstance(node, ast.ClassDef):
            class_name = node.name

            # Skip private classes
            if class_name.startswith('_'):
                continue

            # Check for docstring
            has_docstring = (
                node.body and
                isinstance(node.body[0], ast.Expr) and
                isinstance(node.body[0].value, ast.Constant) and
                isinstance(node.body[0].value.value, str)
            )

            if not has_docstring:
                violations.append(CodeViolation(
                    file_path=file_path,
                    line=node.lineno,
                    column=node.col_offset,
                    violation_type='missing_class_docstring',
                    message=f"Class '{class_name}' missing docstring",
                    severity='medium',
                    suggestion="Add class docstring describing purpose and usage"
                ))

    return violations


def check_test_coverage(
    source_file_path: str,
    test_directory: str = 'tests'
) -> List[CodeViolation]:
    """Check if tests exist for functions in a source file.

    Looks for corresponding test file and verifies that tests exist for
    public functions defined in the source file.

    Args:
        source_file_path: Path to source file to check
        test_directory: Directory containing test files

    Returns:
        List of CodeViolation objects for missing tests

    Example:
        >>> violations = check_test_coverage('src/core/models.py')
        >>> # Checks if tests/test_models.py exists with tests for public functions
    """
    violations = []
    source_path = Path(source_file_path)

    if not source_path.exists():
        logger.warning(f"Source file not found: {source_file_path}")
        return violations

    # Determine expected test file name
    source_name = source_path.stem
    test_file_name = f"test_{source_name}.py"
    test_path = Path(test_directory) / test_file_name

    # Read source file and find public functions
    try:
        with open(source_path, 'r') as f:
            source_code = f.read()

        source_tree = ast.parse(source_code)
    except (OSError, SyntaxError) as e:
        logger.error(f"Failed to parse source file: {e}")
        return violations

    # Collect public functions from source
    public_functions = []
    for node in ast.walk(source_tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            func_name = node.name
            # Only check top-level public functions
            if not func_name.startswith('_'):
                public_functions.append(func_name)

    if not public_functions:
        # No public functions to test
        return violations

    # Check if test file exists
    if not test_path.exists():
        violations.append(CodeViolation(
            file_path=str(source_path),
            line=1,
            column=0,
            violation_type='missing_test_file',
            message=f"Test file not found: {test_path}",
            severity='high',
            suggestion=f"Create {test_path} with tests for {len(public_functions)} functions"
        ))
        return violations

    # Read test file and find test functions
    try:
        with open(test_path, 'r') as f:
            test_code = f.read()

        test_tree = ast.parse(test_code)
    except (OSError, SyntaxError) as e:
        logger.error(f"Failed to parse test file: {e}")
        return violations

    # Collect test function names
    test_functions = set()
    for node in ast.walk(test_tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            if node.name.startswith('test_'):
                test_functions.add(node.name)

    # Check if each public function has a corresponding test
    for func_name in public_functions:
        expected_test_names = [
            f"test_{func_name}",
            f"test_{func_name}_success",
            f"test_{func_name}_basic",
        ]

        has_test = any(test_name in test_functions for test_name in expected_test_names)

        if not has_test:
            violations.append(CodeViolation(
                file_path=str(source_path),
                line=1,
                column=0,
                violation_type='missing_test',
                message=f"No test found for function '{func_name}'",
                severity='medium',
                suggestion=f"Add test_{func_name}() to {test_path}"
            ))

    return violations


def validate_code_file(file_path: str) -> Dict[str, List[CodeViolation]]:
    """Run all validators on a code file.

    Convenience function that runs all available validators on a file
    and returns categorized results.

    Args:
        file_path: Path to Python source file

    Returns:
        Dictionary with violation categories:
        - 'stubs': Stub function violations
        - 'hardcoded': Hardcoded value violations
        - 'docstrings': Missing docstring violations
        - 'tests': Missing test violations

    Example:
        >>> results = validate_code_file('src/core/models.py')
        >>> for category, violations in results.items():
        ...     print(f"{category}: {len(violations)} violations")
    """
    path = Path(file_path)

    if not path.exists():
        logger.error(f"File not found: {file_path}")
        return {
            'stubs': [],
            'hardcoded': [],
            'docstrings': [],
            'tests': []
        }

    # Read file
    try:
        with open(path, 'r') as f:
            code = f.read()
    except OSError as e:
        logger.error(f"Failed to read file: {e}")
        return {
            'stubs': [],
            'hardcoded': [],
            'docstrings': [],
            'tests': []
        }

    # Run validators
    return {
        'stubs': detect_stubs(code, str(path)),
        'hardcoded': detect_hardcoded_values(code, str(path)),
        'docstrings': check_docstring_coverage(code, str(path)),
        'tests': check_test_coverage(str(path))
    }
